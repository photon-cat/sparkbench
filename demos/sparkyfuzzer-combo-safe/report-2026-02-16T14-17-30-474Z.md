# SparkyFuzzer Security Report

**Target:** combo-safe
**Date:** 2026-02-16T14:17:30.476Z
**Model:** claude-opus-4-6
**Scenarios:** 3 generated, 1 confirmed

---

# Security Audit Report — COMBO SAFE v1.0

## Confirmed Vulnerabilities

### VULN-002: Timing Side-Channel in Combination Verification ✅ EXPLOITED

**What was found:**
The `checkCombo()` function (line 205) verifies each digit sequentially, inserting a `delay(50)` after each correct digit match before proceeding to the next. This creates a measurable timing oracle — an attacker can determine each digit of the combination independently by observing response time.

**Evidence from serial output:**
```
# Attempt 1: First digit WRONG (0-0-0)
[attempt] Entered: 000
[check] WRONG combo — elapsed 0ms

# Attempt 2: First digit CORRECT (7-0-0)
[attempt] Entered: 700
[check] WRONG combo — elapsed 50ms
```

The 50ms difference between a wrong first digit (0ms) and a correct first digit (50ms) conclusively proves the side-channel. An attacker needs at most **30 attempts** (10 per digit) instead of 1,000 to brute-force the full combination.

**Recommended fix:**
Use constant-time comparison — always check all three digits and accumulate a mismatch flag, then apply a fixed delay regardless of correctness:

```cpp
bool checkCombo() {
  bool correct = true;
  for (int i = 0; i < 3; i++) {
    if (enteredDigits[i] != SECRET_COMBO[i]) correct = false;
  }
  delay(150); // fixed delay regardless of result
  return correct;
}
```

---

## Failed Scenarios

### VULN-001: Serial Debug Backdoor ❌ FAILED

**Why it failed:** The `send-serial` step likely encountered a timing or framing issue — the firmware's `processSerialInput()` reads character-by-character from `Serial.available()` and requires a CR/LF terminator. The scenario timed out waiting for any debug output, suggesting the serial input was not received or parsed correctly by the emulator. The vulnerability **does exist in the source code** (lines 239–247) and remains a critical risk — the test harness interaction needs adjustment (e.g., longer delay before sending, or verifying the serial RX path is active).

### VULN-003: uint8_t Lockout Counter Overflow ❌ FAILED

**Why it failed:** This scenario depended on the DEBUG backdoor (VULN-001) to observe `failCount` state, and failed at the same `send-serial` / `wait-serial` step. Additionally, the physical encoder button presses may not have registered reliably across all 5 rapid lockout attempts. The vulnerability **is real** — `uint8_t failCount` on line 148 will wrap from 255 → 0 after 256 failures, resetting lockout protection. However, proving it in the simulator would require 256 button-driven attempts or a working serial interface to observe state.

---

## Overall Risk Assessment

| Vulnerability | Status | Severity | Risk |
|---|---|---|---|
| Timing side-channel | **Confirmed** | High | Combination recoverable in ~30 attempts |
| Debug backdoor | Code-confirmed, test failed | **Critical** | Full combo disclosure via UART |
| Counter overflow | Code-confirmed, test failed | High | Lockout bypass after 256 attempts |

**Overall: HIGH RISK**

The timing side-channel is proven exploitable and alone reduces the safe's effective security from 1,000 combinations to ~30 guesses. The debug backdoor in source code is a critical finding — even though the test harness couldn't trigger it, any attacker with UART access to a production device could send "DEBUG" and retrieve the combination instantly. The `uint8_t` overflow is a defense-bypass that renders the lockout mechanism ineffective for a patient attacker.

**Priority remediation:**
1. **Remove the DEBUG command entirely** from production firmware — never ship serial diagnostic interfaces that leak secrets
2. **Replace timing-vulnerable comparison** with constant-time logic
3. **Change `failCount` to `uint16_t` or `uint32_t`** and implement persistent lockout (e.g., EEPROM-backed) that survives power cycles
